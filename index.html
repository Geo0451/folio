<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xbox Dashboard - Remastered</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:'Rajdhani',Arial,sans-serif;background:#000;overflow:hidden;color:#fff;user-select:none}
        #canvas-container{position:absolute;inset:0}
        #canvas{width:100%;height:100%;display:block}
        .crt-overlay{position:fixed;inset:0;z-index:999;pointer-events:none;background:radial-gradient(circle,rgba(0,0,0,0) 60%,rgba(0,0,0,.4) 100%),repeating-linear-gradient(0deg,rgba(0,0,0,.1),rgba(0,0,0,.1) 1px,transparent 1px,transparent 3px);box-shadow:inset 0 0 150px rgba(0,0,0,.8)}
        .ui-overlay{position:relative;z-index:10;height:100vh;display:flex;flex-direction:column;pointer-events:none}
        .ui-overlay>*{pointer-events:auto}
        .top-bar{padding:30px 40px;display:flex;justify-content:space-between;align-items:center;background:linear-gradient(to bottom,rgba(0,20,0,.9),transparent)}
        .logo-container{display:flex;align-items:center;gap:15px;cursor:pointer;filter:drop-shadow(0 0 10px #0f0);transition:transform .2s}
        .logo-container:active{transform:scale(.95)}
        .xbox-logo{width:45px;height:45px;border-radius:50%;background:radial-gradient(circle at 30% 30%,#aaffaa,#0f0);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:26px;color:#030;box-shadow:0 0 15px #0f0}
        .xbox-text{font-size:36px;font-weight:800;letter-spacing:4px;text-shadow:0 0 10px #0f0}
        .menu-container{position:absolute;left:60px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:15px;z-index:2}
        .menu-item{background:linear-gradient(90deg,rgba(0,20,0,.6),transparent);border:1px solid rgba(0,255,0,.1);border-left:4px solid #333;padding:15px 30px;width:320px;color:#888;font-size:24px;font-weight:700;text-transform:uppercase;letter-spacing:2px;cursor:pointer;transition:all .3s cubic-bezier(.2,.8,.2,1);display:flex;align-items:center;gap:15px;backdrop-filter:blur(5px);clip-path:polygon(0 0,100% 0,95% 100%,0% 100%)}
        .menu-item:hover{padding-left:40px;background:linear-gradient(90deg,rgba(0,50,0,.6),transparent);color:#fff;text-shadow:0 0 8px #0f0}
        .menu-item.selected{border-left:4px solid #0f0;background:linear-gradient(90deg,rgba(0,100,0,.8),transparent);color:#fff;transform:scale(1.05) translateX(20px);box-shadow:-10px 0 20px rgba(0,255,0,.2);text-shadow:0 0 15px #0f0}
        .menu-blade{position:absolute;right:-600px;top:0;bottom:0;width:500px;background:rgba(0,10,0,.9);border-left:2px solid #0f0;box-shadow:-20px 0 100px rgba(0,255,0,.1);backdrop-filter:blur(20px);transform:skewX(-5deg);transform-origin:top right;transition:right .5s cubic-bezier(.19,1,.22,1);z-index:20;padding:80px 40px;overflow:hidden}
        .menu-blade.active{right:-40px}
        .blade-content{transform:skewX(5deg);height:100%;overflow-y:auto;padding-right:10px}
        .blade-content::-webkit-scrollbar{width:5px}
        .blade-content::-webkit-scrollbar-thumb{background:#0f0;border-radius:3px}
        .blade-header{font-size:32px;color:#fff;margin-bottom:30px;border-bottom:2px solid rgba(0,255,0,.3);padding-bottom:10px;text-shadow:0 0 10px rgba(0,255,0,.5);font-weight:800}
        .blade-row{display:flex;align-items:center;justify-content:space-between;padding:15px 10px;border-bottom:1px solid rgba(0,255,0,.1);transition:.2s;cursor:pointer;border-radius:4px}
        .blade-row:hover{background:rgba(0,255,0,.1);padding-left:20px}
        .blade-label{font-size:18px;color:#ccc}
        .blade-value{font-size:18px;color:#0f0;font-weight:bold;text-shadow:0 0 8px rgba(0,255,0,.6)}
        .close-btn{position:absolute;top:30px;right:60px;font-size:30px;color:#0f0;cursor:pointer;transform:skewX(5deg);transition:.3s}
        .close-btn:hover{text-shadow:0 0 15px #0f0;transform:skewX(5deg) rotate(90deg)}
    </style>
    <script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
    <div class="crt-overlay"></div>
    <div id="canvas-container"></div>
    <div class="ui-overlay">
        <div class="top-bar">
            <div class="logo-container" onclick="resetCam()">
                <div class="xbox-logo">G</div>
                <div class="xbox-text">GEO K J</div>
            </div>
            <div style="color:#0f0;font-size:20px;text-shadow:0 0 10px #0f0" id="clock">12:00 PM</div>
        </div>
        <div class="menu-container">
            <div class="menu-item" onclick="openBlade('live',0)"><span>üåê</span> About Me</div>
            <div class="menu-item" onclick="openBlade('games',1)"><span>üéÆ</span> Projects</div>
            <div class="menu-item" onclick="openBlade('media',2)"><span>üéµ</span> Experience</div>
            <div class="menu-item" onclick="openBlade('system',3)"><span>‚öôÔ∏è</span> Contact</div>
        </div>
        <div class="menu-blade" id="main-blade">
            <div class="close-btn" onclick="closeBlade()">√ó</div>
            <div class="blade-content" id="blade-content"></div>
        </div>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { Reflector } from 'three/addons/objects/Reflector.js';

        let isActivated = false;
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 5, 25);

        const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 5);
        camera.rotation.set(-0.1, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const latticeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.1 });
        const latticeSphere = new THREE.Mesh(new THREE.SphereGeometry(1, 24, 24), latticeMaterial);
        scene.add(latticeSphere);

        const glowMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.1, side: THREE.BackSide });
        latticeSphere.add(new THREE.Mesh(new THREE.SphereGeometry(0.95, 32, 32), glowMaterial));

        scene.add(new THREE.AmbientLight(0x112211, 1));
        const mainLight = new THREE.PointLight(0x00ff00, 3, 20);
        mainLight.position.set(0, 2, 2);
        scene.add(mainLight);

        function createSoftParticleTexture() {
            const c = document.createElement('canvas');
            c.width = c.height = 128;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            g.addColorStop(0,   'rgba(255,255,255,1)');
            g.addColorStop(0.2, 'rgba(255,255,255,0.5)');
            g.addColorStop(1,   'rgba(255,255,255,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(c);
        }
        const particleSprite = createSoftParticleTexture();

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.15;
        bloomPass.strength = 1.0;
        bloomPass.radius = 0.4;

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(bloomPass);

        const groundMirror = new Reflector(new THREE.PlaneGeometry(50, 50), {
            clipBias: 0.003,
            textureWidth: innerWidth * devicePixelRatio,
            textureHeight: innerHeight * devicePixelRatio,
            color: 0x111111
        });
        groundMirror.position.y = -3;
        groundMirror.rotation.x = -Math.PI / 2;
        scene.add(groundMirror);

        const orbMaterial = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 } },
            vertexShader: `varying vec2 vUv;varying vec3 vPosition;void main(){vUv=uv;vPosition=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
            fragmentShader: `uniform float time;varying vec2 vUv;varying vec3 vPosition;float noise(vec3 p){return fract(sin(dot(p,vec3(12.9898,78.233,45.164)))*43758.5453);}void main(){float pulse=sin(time*2.0)*0.1+0.9;float noiseVal=noise(vPosition+time*0.5);vec3 baseColor=vec3(0.0,1.0,0.1);vec3 glowColor=vec3(0.8,1.0,0.8);float intensity=pow(0.7-dot(vUv-0.5,vUv-0.5),3.0);vec3 finalColor=mix(baseColor,glowColor,noiseVal*0.3);gl_FragColor=vec4(finalColor*pulse*intensity*2.0,0.8);}`,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: true
        });

        const orb = new THREE.Mesh(new THREE.SphereGeometry(1, 64, 64), orbMaterial);
        orb.visible = false;
        scene.add(orb);

        const _wf = new THREE.Mesh(new THREE.SphereGeometry(1.05, 24, 24), new THREE.MeshBasicMaterial({ color: 0x44ff44, wireframe: true, transparent: true, opacity: 0.2 }));
        _wf.visible = false;
        orb.add(_wf);

        const ringGeo = new THREE.TorusGeometry(1.5, 0.015, 16, 100);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.4 });
        const rings = Array.from({ length: 3 }, () => {
            const r = new THREE.Mesh(ringGeo, ringMat.clone());
            r.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
            r.visible = false;
            scene.add(r);
            return r;
        });

        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        window.addEventListener('mousemove', e => {
            mouse.x = (e.clientX / innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / innerHeight) * 2 + 1;
        });

        const ambientCount = 1500;
        const aPos = new Float32Array(ambientCount * 3);
        for (let i = 0; i < ambientCount; i++) {
            aPos[i*3]   = (Math.random() - 0.5) * 25;
            aPos[i*3+1] = (Math.random() - 0.5) * 20;
            aPos[i*3+2] = (Math.random() - 0.5) * 15;
        }
        const aGeo = new THREE.BufferGeometry();
        aGeo.setAttribute('position', new THREE.BufferAttribute(aPos, 3));
        const aMat = new THREE.PointsMaterial({ size: 0.15, map: particleSprite, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false, color: 0x00ff00 });
        const ambientParticles = new THREE.Points(aGeo, aMat);
        scene.add(ambientParticles);

        const energyCount = 200;
        const ePos = new Float32Array(energyCount * 3);
        const eData = Array.from({ length: energyCount }, (_, i) => ({
            angle: (i / energyCount) * Math.PI * 2,
            radius: 0,
            speed: 0.015 + Math.random() * 0.01,
            yOffset: (Math.random() - 0.5) * 5,
            currentPos: new THREE.Vector3(),
            targetRadius: 1.8 + Math.random() * 3
        }));
        const eGeo = new THREE.BufferGeometry();
        eGeo.setAttribute('position', new THREE.BufferAttribute(ePos, 3));
        const eMat = new THREE.PointsMaterial({ size: 0.22, map: particleSprite, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false, color: 0xaaffaa });
        const energyParticles = new THREE.Points(eGeo, eMat);
        scene.add(energyParticles);

        function activateSphere() {
            if (isActivated) return;
            isActivated = true;
            gsap.to(latticeMaterial, { opacity: 0, duration: 1, onComplete: () => { latticeSphere.visible = false; } });
            gsap.to(glowMaterial, { opacity: 0, duration: 1 });
            orb.visible = true;
            orb.scale.set(0.01, 0.01, 0.01);
            gsap.to(orb.scale, { x: 1, y: 1, z: 1, duration: 40, ease: 'elastic.out(1, 0.3)' });
            rings.forEach((r, i) => {
                r.visible = true;
                r.scale.set(0.1, 0.1, 0.1);
                gsap.to(r.scale, { x: 1, y: 1, z: 1, duration: 1.5, delay: 0.5 + i * 0.2, ease: 'back.out(1.7)' });
            });
            gsap.to(aMat, { opacity: 0.42, duration: 3, delay: 1 });
            gsap.to(eMat, { opacity: 0.9, duration: 2, delay: 0.5 });
            setTimeout(() => {
                eData.forEach((p, i) => gsap.to(p, { radius: p.targetRadius, duration: 1.5, delay: i * 0.002, ease: 'power2.out' }));
            }, 1000);
        }

        const clock = new THREE.Clock();
        const cameraTargets = [
            { pos: new THREE.Vector3(-2.0,  1.2, 4.0), rot: new THREE.Euler(-0.1, -0.4,  0) },
            { pos: new THREE.Vector3( 3.0, -1.8, 3.0), rot: new THREE.Euler( 0.4,  0.6,  0.1) },
            { pos: new THREE.Vector3( 0,    3.5, 3.5), rot: new THREE.Euler(-0.8,  0,    0) },
            { pos: new THREE.Vector3(-3.5, -0.5, 2.0), rot: new THREE.Euler( 0.1, -1.1,  0) }
        ];

        let targetPos = new THREE.Vector3(0, 1, 5);
        let targetRot = new THREE.Euler(-0.1, 0, 0);
        const _quat = new THREE.Quaternion();
        const _mp   = new THREE.Vector3();
        const _rep  = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if (!isActivated) {
                latticeSphere.rotation.y += 0.003;
                latticeSphere.rotation.x += 0.001;
                const b = Math.sin(time) * 0.4 + 1;
                latticeSphere.scale.set(b, b, b);
            }

            camera.position.lerp(targetPos, 0.04);
            camera.quaternion.slerp(_quat.setFromEuler(targetRot), 0.04);

            if (isActivated) {
                orbMaterial.uniforms.time.value = time;
                rings.forEach((r, i) => {
                    r.rotation.x += 0.01 * (i + 1);
                    r.rotation.y += 0.005 * (i + 1);
                });
                ambientParticles.rotation.y = time * 0.02;

                if (eData.length) {
                    const ep = energyParticles.geometry.attributes.position.array;
                    raycaster.setFromCamera(mouse, camera);
                    raycaster.ray.at(camera.position.length(), _mp);
                    for (let i = 0; i < energyCount; i++) {
                        const p = eData[i];
                        p.angle += p.speed;
                        const r = (p.radius || 0) + Math.sin(time * 3 + i) * 0.05;
                        const tx = Math.cos(p.angle) * r;
                        const ty = p.yOffset + Math.sin(time * 2 + i) * 0.1;
                        const tz = Math.sin(p.angle) * r;
                        const cur = p.currentPos;
                        const dist = _mp.distanceTo(cur);
                        if (dist < 2.5 && dist > 0.01) {
                            const str = (2.5 - dist) / 2.5;
                            cur.add(_rep.copy(cur).sub(_mp).normalize().multiplyScalar(0.15 * str));
                        }
                        cur.x += (tx - cur.x) * 0.08;
                        cur.y += (ty - cur.y) * 0.08;
                        cur.z += (tz - cur.z) * 0.08;
                        ep[i*3]   = cur.x;
                        ep[i*3+1] = cur.y;
                        ep[i*3+2] = cur.z;
                    }
                    energyParticles.geometry.attributes.position.needsUpdate = true;
                }
            }
            composer.render();
        }
        animate();

        const portfolioData = {
            live:   { title: 'User Profile',      items: [{ label: 'Developer',    value: 'Creative Technologist' }, { label: 'Focus',  value: 'Interactive Web / 3D' }, { label: 'Level', value: 'Senior' }, { label: 'Gamerscore', value: '9,001 G' }, { label: 'Status', value: 'Looking for Projects' }] },
            games:  { title: 'Featured Projects', items: [{ label: 'Xbox Dashboard', value: 'Three.js / GLSL' }, { label: 'Boid Sim', value: 'Cellular Automata' }] },
            media:  { title: 'Experience',         items: [{ label: '2022-Present', value: 'Senior Dev @ TechCorp' }, { label: '2020-2022', value: 'Creative Engineer @ Agency' }, { label: '2018-2020', value: 'Fullstack Dev @ Startup' }] },
            system: { title: 'Contact',            items: [{ label: 'Email',       value: 'dev@null.com' }, { label: 'LinkedIn', value: 'dev@null.com' }, { label: 'Instagram', value: '@creative_dev' }, { label: 'GitHub', value: 'github.com/profile' }] }
        };

        const menuItems   = document.querySelectorAll('.menu-item');
        const mainBlade   = document.getElementById('main-blade');
        const bladeContent = document.getElementById('blade-content');

        window.openBlade = (type, index) => {
            activateSphere();
            menuItems.forEach((el, i) => el.classList.toggle('selected', i === index));
            const { title, items } = portfolioData[type];
            bladeContent.innerHTML = `<div class="blade-header">${title}</div>` +
                items.map(({ label, value }) => `<div class="blade-row"><span class="blade-label">${label}</span><span class="blade-value">${value}</span></div>`).join('');
            mainBlade.classList.add('active');
            if (cameraTargets[index]) {
                targetPos.copy(cameraTargets[index].pos);
                targetRot.copy(cameraTargets[index].rot);
            }
        };

        window.closeBlade = window.resetCam = () => {
            mainBlade.classList.remove('active');
            targetPos.set(0, 1, 5);
            targetRot.set(-0.1, 0, 0);
        };

        setInterval(() => {
            document.getElementById('clock').innerText = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }, 1000);

        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
            composer.setSize(innerWidth, innerHeight);
        });
    </script>
</body>
</html>
