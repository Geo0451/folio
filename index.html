<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xbox Dashboard - Remastered</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Rajdhani', 'Arial', sans-serif;
            background: #000;
            overflow: hidden;
            color: white;
            user-select: none;
        }

        #canvas-container { position: absolute; inset: 0; z-index: 0; }
        #canvas { width: 100%; height: 100%; display: block; }

        /* CRT Vignette & Scanlines */
        .crt-overlay {
            position: fixed;
            inset: 0;
            z-index: 999;
            pointer-events: none;
            background: 
                radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.4) 100%),
                repeating-linear-gradient(0deg, rgba(0,0,0,0.1), rgba(0,0,0,0.1) 1px, transparent 1px, transparent 3px);
            box-shadow: inset 0 0 150px rgba(0,0,0,0.8);
        }

        .ui-overlay {
            position: relative;
            z-index: 10;
            height: 100vh;
            display: flex;
            flex-direction: column;
            pointer-events: none;
        }

        .ui-overlay > * { pointer-events: auto; }

        .top-bar {
            padding: 30px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0,20,0,0.9), transparent);
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            filter: drop-shadow(0 0 10px #0f0);
            transition: transform 0.2s;
        }
        .logo-container:active { transform: scale(0.95); }

        .xbox-logo {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #aaffaa, #00ff00);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 26px;
            color: #003300;
            box-shadow: 0 0 15px #0f0;
        }

        .xbox-text {
            font-size: 36px;
            font-weight: 800;
            letter-spacing: 4px;
            color: #fff;
            text-shadow: 0 0 10px #0f0;
        }

        .menu-container {
            position: absolute;
            left: 60px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 2;
        }

        .menu-item {
            background: linear-gradient(90deg, rgba(0,20,0,0.6), transparent);
            border: 1px solid rgba(0,255,0,0.1);
            border-left: 4px solid #333;
            padding: 15px 30px;
            width: 320px;
            color: #888;
            font-size: 24px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 15px;
            backdrop-filter: blur(5px);
            clip-path: polygon(0 0, 100% 0, 95% 100%, 0% 100%);
        }

        .menu-item:hover {
            padding-left: 40px;
            background: linear-gradient(90deg, rgba(0,50,0,0.6), transparent);
            color: #fff;
            text-shadow: 0 0 8px #0f0;
        }

        .menu-item.selected {
            border-left: 4px solid #0f0;
            background: linear-gradient(90deg, rgba(0,100,0,0.8), transparent);
            color: #fff;
            transform: scale(1.05) translateX(20px);
            box-shadow: -10px 0 20px rgba(0,255,0,0.2);
            text-shadow: 0 0 15px #0f0;
        }

        /* Blade Panel */
        .menu-blade {
            position: absolute;
            right: -600px;
            top: 0;
            bottom: 0;
            width: 500px;
            background: rgba(0, 10, 0, 0.9);
            border-left: 2px solid #0f0;
            box-shadow: -20px 0 100px rgba(0,255,0,0.1);
            backdrop-filter: blur(20px);
            transform: skewX(-5deg);
            transform-origin: top right;
            transition: right 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            z-index: 20;
            padding: 80px 40px;
            overflow: hidden;
        }

        .menu-blade.active { right: -40px; }
        
        .blade-content { transform: skewX(5deg); height: 100%; overflow-y: auto; padding-right: 10px; }
        .blade-content::-webkit-scrollbar { width: 5px; }
        .blade-content::-webkit-scrollbar-thumb { background: #0f0; border-radius: 3px; }

        .blade-header {
            font-size: 32px;
            color: #fff;
            margin-bottom: 30px;
            border-bottom: 2px solid rgba(0,255,0,0.3);
            padding-bottom: 10px;
            text-shadow: 0 0 10px rgba(0,255,0,0.5);
            font-weight: 800;
        }

        .blade-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 10px;
            border-bottom: 1px solid rgba(0,255,0,0.1);
            transition: 0.2s;
            cursor: pointer;
            border-radius: 4px;
        }

        .blade-row:hover { background: rgba(0,255,0,0.1); padding-left: 20px; }
        .blade-label { font-size: 18px; color: #ccc; }
        .blade-value { font-size: 18px; color: #0f0; font-weight: bold; text-shadow: 0 0 8px rgba(0,255,0,0.6); }

        .close-btn {
            position: absolute;
            top: 30px;
            right: 60px;
            font-size: 30px;
            color: #0f0;
            cursor: pointer;
            transform: skewX(5deg);
            transition: 0.3s;
        }
        .close-btn:hover { text-shadow: 0 0 15px #0f0; transform: skewX(5deg) rotate(90deg); }

    </style>
    <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
    <div class="crt-overlay"></div>
    <div id="canvas-container"></div>

    <div class="ui-overlay">
        <div class="top-bar">
            <div class="logo-container" onclick="resetCam()">
                <div class="xbox-logo">G</div>
                <div class="xbox-text">GEO K J</div>
            </div>
            <div style="color: #0f0; font-size: 20px; text-shadow: 0 0 10px #0f0;" id="clock">12:00 PM</div>
        </div>

        <div class="menu-container">
            <div class="menu-item" onclick="openBlade('live', 0)">
                <span>üåê</span> About Me
            </div>
            <div class="menu-item" onclick="openBlade('games', 1)">
                <span>üéÆ</span> Projects
            </div>
            <div class="menu-item" onclick="openBlade('media', 2)">
                <span>üéµ</span> Experience
            </div>
            <div class="menu-item" onclick="openBlade('system', 3)">
                <span>‚öôÔ∏è</span> Contact
            </div>
        </div>

        <div class="menu-blade" id="main-blade">
            <div class="close-btn" onclick="closeBlade()">√ó</div>
            <div class="blade-content" id="blade-content"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
        import { Reflector } from 'three/addons/objects/Reflector.js';

        // --- State ---
        let isActivated = false;

        // --- Unified Scene (starts as lattice, transforms on interaction) ---
        
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 5, 25);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 5);
        camera.rotation.set(-0.1, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);
        
        // Create the lattice sphere (initially visible)
        const latticeGeometry = new THREE.SphereGeometry(1, 24, 24);
        const latticeMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true,
            transparent: true,
            opacity: 0.1
        });
        const latticeSphere = new THREE.Mesh(latticeGeometry, latticeMaterial);
        scene.add(latticeSphere);
        
        // Inner glow for lattice
        const glowGeometry = new THREE.SphereGeometry(0.95, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.1,
            side: THREE.BackSide
        });
        const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
        latticeSphere.add(glowSphere);
        
        // Lights
        scene.add(new THREE.AmbientLight(0x112211, 1));
        const mainLight = new THREE.PointLight(0x00ff00, 3, 20);
        mainLight.position.set(0, 2, 2);
        scene.add(mainLight);

        // --- Texture Generator (Soft Particles) ---
        function createSoftParticleTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        const particleSprite = createSoftParticleTexture();

        // --- Post-Processing ---
        const renderScene = new RenderPass(scene, camera);
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.15;
        bloomPass.strength = 1.0; 
        bloomPass.radius = 0.4;

        const bokehPass = new BokehPass(scene, camera, {
            focus: 5.0,
            aperture: 0.00002,
            maxblur: 0.01
        });

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
        composer.addPass(bokehPass);

        // --- Reflective Floor ---
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMirror = new Reflector(groundGeometry, {
            clipBias: 0.003,
            textureWidth: window.innerWidth * window.devicePixelRatio,
            textureHeight: window.innerHeight * window.devicePixelRatio,
            color: 0x111111
        });
        groundMirror.position.y = -3;
        groundMirror.rotation.x = -Math.PI / 2;
        scene.add(groundMirror);

        // --- Plasma Orb (initially hidden) ---
        const plasmaVertexShader = `
            varying vec2 vUv;
            varying vec3 vPosition;
            void main() {
                vUv = uv;
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const plasmaFragmentShader = `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vPosition;

            float noise(vec3 p) {
                return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
            }

            void main() {
                float pulse = sin(time * 2.0) * 0.1 + 0.9;
                float noiseVal = noise(vPosition + time * 0.5);
                vec3 baseColor = vec3(0.0, 1.0, 0.1);
                vec3 glowColor = vec3(0.8, 1.0, 0.8);
                
                float intensity = pow(0.7 - dot(vUv - 0.5, vUv - 0.5), 3.0);
                vec3 finalColor = mix(baseColor, glowColor, noiseVal * 0.3);
                gl_FragColor = vec4(finalColor * pulse * intensity * 2.0, 0.8);
            }
        `;

        const orbMaterial = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 } },
            vertexShader: plasmaVertexShader,
            fragmentShader: plasmaFragmentShader,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: true
        });

        const orbGeometry = new THREE.SphereGeometry(1, 64, 64);
        const orb = new THREE.Mesh(orbGeometry, orbMaterial);
        orb.visible = false; // Hidden initially
        scene.add(orb);

        const wireframeGeometry = new THREE.SphereGeometry(1.05, 24, 24);
        const wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0x44ff44,
            wireframe: true,
            transparent: true,
            opacity: 0.2
        });
        const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
        wireframe.visible = false; // Hidden initially
        orb.add(wireframe);

        const ringGeometry = new THREE.TorusGeometry(1.5, 0.015, 16, 100);
        const ringMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.4 });
        
        const rings = [];
        for(let i=0; i<3; i++){
            const r = new THREE.Mesh(ringGeometry, ringMaterial.clone());
            r.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
            r.visible = false; // Hidden initially
            scene.add(r);
            rings.push(r);
        }

        // --- Particles (initially hidden) ---
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // Ambient Dust
        const ambientCount = 1500;
        const aGeo = new THREE.BufferGeometry();
        const aPos = new Float32Array(ambientCount * 3);
        for(let i=0; i<ambientCount; i++) {
            aPos[i*3] = (Math.random() - 0.5) * 25;
            aPos[i*3+1] = (Math.random() - 0.5) * 20;
            aPos[i*3+2] = (Math.random() - 0.5) * 15;
        }
        aGeo.setAttribute('position', new THREE.BufferAttribute(aPos, 3));
        const aMat = new THREE.PointsMaterial({ 
            size: 0.15, 
            map: particleSprite, 
            transparent: true, 
            opacity: 0,
            blending: THREE.AdditiveBlending, 
            depthWrite: false, 
            color: 0x00ff00 
        });
        const ambientParticles = new THREE.Points(aGeo, aMat);
        scene.add(ambientParticles);

        // Energy Swirl
        const energyCount = 200;
        const eGeo = new THREE.BufferGeometry();
        const ePos = new Float32Array(energyCount * 3);
        const eData = []; 
        for(let i=0; i<energyCount; i++) {
            const angle = (i / energyCount) * Math.PI * 2;
            const radius = 1.8 + Math.random() * 3;
            const x = 0;
            const y = 0;
            const z = 0;
            ePos[i*3] = x;
            ePos[i*3+1] = y;
            ePos[i*3+2] = z;
            eData.push({ 
                angle, 
                radius: 0,
                speed: 0.015 + Math.random() * 0.01, 
                yOffset: (Math.random() - 0.5) * 5, 
                currentPos: new THREE.Vector3(x, y, z),
                targetRadius: radius
            });
        }
        eGeo.setAttribute('position', new THREE.BufferAttribute(ePos, 3));
        const eMat = new THREE.PointsMaterial({ 
            size: 0.22, 
            map: particleSprite, 
            transparent: true, 
            opacity: 0,
            blending: THREE.AdditiveBlending, 
            depthWrite: false, 
            color: 0xaaffaa 
        });
        const energyParticles = new THREE.Points(eGeo, eMat);
        scene.add(energyParticles);

        // --- Activation Function ---
        function activateSphere() {
            if (isActivated) return;
            isActivated = true;
            
            // Hide lattice sphere
            gsap.to(latticeMaterial, {
                opacity: 0,
                duration: 1,
                onComplete: () => {
                    latticeSphere.visible = false;
                }
            });
            gsap.to(glowMaterial, {
                opacity: 0,
                duration: 1
            });
            
            // Show and animate plasma orb
            orb.visible = true;
            orb.scale.set(0.01, 0.01, 0.01);
            gsap.to(orb.scale, {
                x: 1, y: 1, z: 1,
                duration: 40,
                ease:   "elastic.out(1, 0.3)"
            });
            
            // Show rings with stagger
            rings.forEach((r, i) => {
                r.visible = true;
                r.scale.set(0.1, 0.1, 0.1);
                gsap.to(r.scale, {
                    x: 1, y: 1, z: 1,
                    duration: 1.5,
                    delay: 0.5 + i * 0.2,
                    ease: "back.out(1.7)"
                });
            });
            
            // Fade in ambient particles
            gsap.to(aMat, {
                opacity: 0.42,
                duration: 3,
                delay: 1
            });
            
            // Fade in and expand energy particles
            gsap.to(eMat, {
                opacity: 0.9,
                duration: 2,
                delay: 0.5
            });
            
            setTimeout(() => {
                eData.forEach((particle, i) => {
                    gsap.to(particle, {
                        radius: particle.targetRadius,
                        duration: 1.5,
                        delay: i * 0.002,
                        ease: "power2.out"
                    });
                });
            }, 1000);
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        
        const cameraTargets = [
                { pos: new THREE.Vector3(-2.0, 1.2, 4.0), rot: new THREE.Euler(-0.1, -0.4, 0) },     // Profile / Slight Top Down
                { pos: new THREE.Vector3(3.0, -1.8, 3.0), rot: new THREE.Euler(0.4, 0.6, 0.1) },    // Extreme Low Angle Side
                { pos: new THREE.Vector3(0, 3.5, 3.5), rot: new THREE.Euler(-0.8, 0, 0) },          // High Angle Overlooking Swirl
            { pos: new THREE.Vector3(-3.5, -0.5, 2.0), rot: new THREE.Euler(0.1, -1.1, 0) }
        ];

        let targetPos = new THREE.Vector3(0, 1, 5);
        let targetRot = new THREE.Euler(-0.1, 0, 0);

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // Lattice breathing (when not activated)
            if (!isActivated) {
                latticeSphere.rotation.y += 0.003;
                latticeSphere.rotation.x += 0.001;
                const breathe = Math.sin(time) * 0.4 + 1;
                latticeSphere.scale.set(breathe, breathe, breathe);
            }

            // Camera smoothing
            camera.position.lerp(targetPos, 0.04);
            camera.quaternion.slerp(new THREE.Quaternion().setFromEuler(targetRot), 0.04);

            // Orb & rings (when activated)
            if (isActivated) {
                orbMaterial.uniforms.time.value = time;
                //orb.rotation.y += 0.5;
                rings.forEach((r, i) => {
                    r.rotation.x += 0.01 * (i + 1);
                    r.rotation.y += 0.005 * (i + 1);
                });

                // Ambient drift
                ambientParticles.rotation.y = time * 0.02;

                // Reactive energy swirl
                if (energyParticles && eData.length > 0) {
                    const ePositions = energyParticles.geometry.attributes.position.array;
                    
                    // Project mouse position into world space at the sphere's depth
                    raycaster.setFromCamera(mouse, camera);
                    const sphereDistance = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
                    const mousePoint = new THREE.Vector3();
                    raycaster.ray.at(sphereDistance, mousePoint);

                    for(let i=0; i<energyCount; i++) {
                        eData[i].angle += eData[i].speed;
                        const r = (eData[i].radius || 0) + Math.sin(time * 3 + i) * 0.05;
                        const targetX = Math.cos(eData[i].angle) * r;
                        const targetY = eData[i].yOffset + Math.sin(time * 2 + i) * 0.1;
                        const targetZ = Math.sin(eData[i].angle) * r;

                        const current = eData[i].currentPos;
                        
                        const dist = mousePoint.distanceTo(current);
                        if(dist < 2.5 && dist > 0.01) {
                            const repulsionStrength = (2.5 - dist) / 2.5;
                            const repulsion = current.clone().sub(mousePoint).normalize().multiplyScalar(0.15 * repulsionStrength);
                            current.add(repulsion);
                        }

                        current.x += (targetX - current.x) * 0.08;
                        current.y += (targetY - current.y) * 0.08;
                        current.z += (targetZ - current.z) * 0.08;

                        ePositions[i*3] = current.x;
                        ePositions[i*3+1] = current.y;
                        ePositions[i*3+2] = current.z;
                    }
                    energyParticles.geometry.attributes.position.needsUpdate = true;
                }
            }

            composer.render();
        }

        animate();

        // --- UI Logic ---
        const portfolioData = {
                'live': { title: 'User Profile', items: [ { label: 'Developer', value: 'Creative Technologist' }, { label: 'Focus', value: 'Interactive Web / 3D' }, { label: 'Level', value: 'Senior' }, { label: 'Gamerscore', value: '9,001 G' }, { label: 'Status', value: 'Looking for Projects' } ] },
                'games': { title: 'Featured Projects', items: [ { label: 'Xbox Dashboard', value: 'Three.js / GLSL' },{ label: 'Boid Sim', value: 'Cellular Automata' }, ] },
                'media': { title: 'Experience', items: [ { label: '2022-Present', value: 'Senior Dev @ TechCorp' }, { label: '2020-2022', value: 'Creative Engineer @ Agency' }, { label: '2018-2020', value: 'Fullstack Dev @ Startup' } ] },
                'system': { title: 'Contact', items: [ { label: 'Email', value: 'dev@null.com' }, { label: 'LinkedIn', value: 'dev@null.com' }, { label: 'Instagram', value: '@creative_dev' }, { label: 'GitHub', value: 'github.com/profile' } ] }
            };

        window.openBlade = function(type, index) {
            activateSphere(); // Activate on menu interaction
            document.querySelectorAll('.menu-item').forEach((el, i) => el.classList.toggle('selected', i === index));
            const data = portfolioData[type];
            const content = document.getElementById('blade-content');
            let html = `<div class="blade-header">${data.title}</div>`;
            data.items.forEach(item => { html += `<div class="blade-row"><span class="blade-label">${item.label}</span><span class="blade-value">${item.value}</span></div>`; });
            content.innerHTML = html;
            document.getElementById('main-blade').classList.add('active');
            if(cameraTargets[index]) {
                targetPos.copy(cameraTargets[index].pos);
                targetRot.copy(cameraTargets[index].rot);
            }
        }

        window.closeBlade = function() {
            document.getElementById('main-blade').classList.remove('active');
            targetPos.set(0, 1, 5);
            targetRot.set(-0.1, 0, 0);
        }

        window.resetCam = function() { 
            window.closeBlade(); 
        }

        setInterval(() => {
            document.getElementById('clock').innerText = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }, 1000);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
